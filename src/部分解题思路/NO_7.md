# 重建二叉树

本题是通过前序遍历和中序遍历来重建二叉树，这类题都是通过将一个大的二叉树分解成一个个小的二叉树来实现的。这题在LeetCode里面有，[construct-binary-tree-from-preorder-and-inorder-traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/),可以去看看并且测试一下自己的代码。

大体的思路就是先根据前序遍历的第一个数字确定根节点，然后在中序遍历中找到根节点的位置，中序遍历中根节点的左边就是左子树，根节点右边就是右子树。接着就是递归，在前序遍历中可以知道左子树的根节点，在中序遍历中可以知道左子树的左、右子树。右子树同理。

来看看具体例子

```
    1
   / \
  2   3
 /   /  \
4   5    6
 \      /
  7    8 
```

前序遍历序列{1 2 4 7 3 5 6 8}

中序遍历序列{4 7 2 1 5 3 8 6}

我们先把前序遍历分解一下

```
1是根节点，
{2 4 7}是左子树，               {3 5 6 8}是右子树，
2是根节点                       3是根节点
{4 7}是左子树，没有右子树         {5}是左子树   {6 8}是右子树
4是根节点                                    6是根节点
{7}是右子树                                  {8}是左子树
```

前面这些分析，想说的其实就是**对于前序遍历的每一个树或者子树，第一个数字都是这个树的根节点**，这是单独从前序遍历可以得到的。但是有个问题，我们来看原始的前序遍历序列，1是根节点现在我们知道了，后面的那些序列我们只能知道前面一部分是左子树，后面一部分是右子树。但是这个分界线在哪呢？就需要其他条件帮我们确认了，我们从中序遍历可以知道1的左子树有3个节点，所以在前序遍历中，1的后面三个都是左子树，第四个数字3包括后面的所有数字都属于右子树了。这样递归下去我们就可以构建我们的二叉树了。

下面来分解一下中序遍历，单独从中序遍历好像得不出什么结论，但是我们在前序遍历中可以知道每一棵字树的根节点，这样从中序遍历就可以得到很多信息了，包括前面说的，可以知道一个根节点右子树有多少个节点，左子树有多少个节点。

```
中序遍历序列{4 7 2 1 5 3 8 6}
前面知道根节点是1，所以
左子树{4 7 2}                 右子树{5 3 8 6}
2是根节点					  3是根节点
左子树{4 7}				   左子树{5}  右子树{8 6}
```

所以我们每次递归按传入的参数之一就是前序遍历的第一个节点，这个节点就是根节点，知道了根节点还要知道具体的各个节点，所以我们要把每棵子树的所有后序遍历序列传入递归函数。

来看一下前面的例子。前序遍历序列{1 2 4 7 3 5 6 8} ，中序遍历序列{4 7 2 1 5 3 8 6}

根据前序遍历的第一个数字，我们知道1是根节点，在中序遍历中找到1，左边为左子树，右边为右子树。对于左子树，在前序遍历中，根节点的后一个节点就是左子树的根节点，所以我们把2和中序遍历中的{4 7 2}传入下一个递归函数，根据这些条件就可以构建左子树了。对于右子树呢？我们知道在后序遍历中，根节点1后面的数字都是右子树，但是右子树的根节点在哪呢？肯定还是要在前序遍历中找，前面我们知道了左节点是 {4 7 2}这三个数，所以前序遍历中，根节点1的后三个数字是右子树，所以前序遍历中{3 5 6 8}是右子树的序列，我们把右子树的根节点3传进去，再把中序遍历中右子树的所有节点{5 3 8 6}传入递归函数里面。这样实现递归构建二叉树。



