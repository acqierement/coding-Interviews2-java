## 数值的整数次方

要考虑到指数是负数的情况，我们对于负数的次方，比如2的负2次方，我们把2先倒数变成1/2，-2取绝对值变成2,

2的负2次方变成1/2的2次方。但是如果我们传入的数字是是Integer.MIN_VALUE的时候就需要特别注意了。

我们知道java中int是32位。所以int的范围是`-2147483648 ~ 2147483647`可以看到是不对称的，那么-2147483648的绝对值是什么呢？大家去试一下会发现-2147483648的绝对值还是-2147483648。

我们来复习一下基础知识，`-2147483648 ~ 2147483647`==`-2^31 ~ (2^31)-1 `

在计算机中，最高位是符号位，所以最大正整数2147483647用2进制表示是011...111（第一位是0，后面跟31个1）

负数-2147483647用2进制表示是111...1111（32位都是1）

那么 -2147483648去哪了？因为有一个特殊情况0这个数，如果问你0怎么表示，大家肯定知道32位都是0，只是第一位符号位是0，表示正数，我们可以说是 +0，还有一种情况，第一位是符号位是1，后面都是0（100...000)，这可以说是 -0。可以看到 +0和 -0都表示0，重复了，**所以我们规定 -0（100...000)就代表 -2147483648**。

解决了这个疑问还有一点要讲一下，在计算机底层，1我们是用（0000...0001）表示，而 -1 就不一样了，我们原本的逻辑是第一位符号位是1，表示负数，然后后面数值部分是1，也就是（10000....00001）用这个数表示 -1，但是计算机在存储的时候，会把负数的进行一层转化，**把除符号位的数值 部分取反加一**，对于（1000....00001）就是前面的1不变，后面的数字都取反，1变0, 0变1，变成（11111....111110），然后再加一，变成（11111....1111）都是1的样子。

所以 1在计算机中是以（00000...0001）存储的， -1是以（1111....1111）存储的。

计算机怎么把负数变成它的绝对值的，负数的绝对值操作其实就是把所有位数（包括符号位）进行取反，再加一。

-1（1111.....1111）都取反变成（0000....00000）再加一变成（00000...00001）就是1的样子了。

好，回到最初的问题。-2147483648的绝对值为什么还是-2147483648，我们知道32位整数中不包含2147483648，所以肯定不会有正确答案的，我们来看看为什么绝对值会是-2147483648

我们前面知道最小值 -2147483648是用 -0（1000...0000）表示的，这个数字在计算机中保存的时候要对除了符号位的数值部分取反加一，你会发现还是1000...00000，然后对它进行取绝对值，所有符号都取反，然后再加一，你又发现了还是10000...00000，所以-2147483648的绝对值还是 -2147483648。

所以最后回到前面，我们要对负指数进行操作，要考虑到这个特殊的-2147483648，也就是java中的Integer.MIN_VALUE。我们对负指数就需要点手段。具体看代码。