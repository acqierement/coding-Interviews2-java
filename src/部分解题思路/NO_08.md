中序遍历的下一个节点

我们先来看看最基本的子树

```
 	 2
 	/  \
   1    3
```

中序遍历顺序是左、中、右，所以中也就是根节点，它的下一个节点一定在它右子树里面，具体在右子树的哪里呢？在右子树中，第一个遍历的节点就是右子树中最左边的节点。所以也就有了第一个结论：**如果一个节点有右子树，那么下一个节点就在右子树中最左边的节点。**当然，最左边这个说法肯定不太对，但大家一定明白我的意思。

然后，如果没有右节点呢？我们把上面那个子树的3擦掉，1的下一个节点就是2，所以第二个结论：**如果一个节点没有右子树，但是如果这个节点是它父节点的左节点。那么这个节点的下一个节点是它的父节点。有点绕，看上面最基本的子树，1没有右节点，1是2的左节点，所以1的下一个节点是2**

如果一个节点没有右节点，它还是父节点的右节点，就沿着指向父节点的指针向上遍历，直到找到一个是它父节点的左子节点的节点。书上的原话，是不是有点绕，没事，咱们换个角度看一下。一个节点没有右节点，它还是父节点的右节点，这是一中什么情况呢？假设中序遍历序列是{1 2 3 4 5 6}，其中3是根节点，12是左子树，456是右子树，假设6是右子树的根节点，那么6这个节点就是3的左节点，而6只有左子树，没有右子树。在我们这个序列中6没有下一个节点，6要想有下一个节点，就需要中序遍历是{1 2 3 4 5 6 7 8 9}，假设3是7的左节点，8是7的右节点。所以6在123456中是属于最靠右的那个节点，但是在更宏观上来看，123456是属于整棵树的左子树，左子树的最后一个节点的下一个节点就是根节点，最后其实也就是前面最基本子树的1和2的关系。

第三个结论：**一个节点没有右节点，它还是父节点的右节点，那么这个节点在它当前树中是没有下一个节点的，如果想要有下一个节点，那么它所在的这棵树必须是更大的一棵树的左子树，这样它的下一个节点就是上层树的根节点。**



代码的思路就是如果有右子树，就遍历右子树，找到“最靠左的节点”

如果没有右子树，就找父节点，如果当前节点所在的树是父节点的右半部分，就继续向上找父节点。直到父节点为空，就返回父节点（当前父节点就是空的），如果父节点的左子树是当前节点所在的子树，也返回这个父节点。