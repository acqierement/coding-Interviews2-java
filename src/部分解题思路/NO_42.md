# 42.连续子数组的最大和

原本这题觉得无从下手，后面发现这题在leetCode上被标记为easy，其实还是很简单的。

## 简单解法

举个例子{1 -2 3 10 -4}。要得到最后的结果，肯定是要遍历一遍的，我们一个个遍历过去。

第一个是1，现在和是1，第二个是-2，现在和是-1，第三个是3，现在和是2，我们发现加上3后和变成了2，还不如不加，所以我们不要前面的哪些数了，从3继续开始。

我们发现规律了，我们用**一个变量保存当前子数组的和**，当这个子数组的和还比一个单独的数小的时候，我们就可以判断这个子数组没前途了，重新开始一个新的子数组。当然**还需要一个变量保存这个过程中出现的最大值**，也就是我们最后的结果

所以最简单的做法就是遍历这个数组，然后更新我们的这两个变量，确实是很easy。

## 动态规划

这题的动态规划也很简单，主要就是要找到递归关系。思路还是和前面一样，其实前面已经提到了，当我们加上3的时候，发现和反而变小了，所以我们不要前面这个子数组了，从3为起点重新开始计算子数组。

什么时候加上一个数之后，和反而变小了？就是加上一个负数的时候，所以我们的关系就有了

dp[i] =dp[i-1] > 0 ? dp[i-1]+nums[i] : nums[i];

翻译一下就是第i个数字的子数组和，要看i-1个数字的子数组和是不是负数，如果是负数的话，就不要前面的和了，从当前的数字开始；如果不是负数的话，就接着下去。所以和前面算法是一样的道理。

